# -*- coding: utf-8 -*-
"""
Created on Tue Apr 21 18:02:50 2020

@author: mkv10
"""


"""
less_3_task_2
2. Во втором массиве сохранить индексы четных элементов первого массива.
 Например, если дан массив со значениями 8, 3, 15, 6, 4, 2,
второй массив надо заполнить значениями 0, 3, 4, 5 (помните, что индексация начинается с нуля),
т. к. именно в этих позициях первого массива стоят четные числа.
"""
import sys
import random
from pympler import asizeof

def memory_func(num):
    if type(num) == str:
        return f'asizeof - {asizeof.asizeof(num)}, sys - {sys.getsizeof(num)}'
    return sys.getsizeof(num)


def even_func(n,answer=''):
    """
    Функция выводит все четные индексы
    :param n: размер списка и диапозон рандомных чискл
    :param answer: переменная string для записи ответа
    :return: Возвращает количество памяти которое задействовала перменная
    """
    for i in range(n + 1):
        array = random.randint(0, n*2)
        if array % 2 == 0:
            answer += f'{str(i)}'
            # Для хранения  индексов используется строка.
    return print(f'Размер answer {memory_func(answer)}\n'
                 f'Пазмер переменной n {memory_func(n)}')


n = 1000
even_func(n)

"""
В скрипте я использовал string для хранения четных индексов, 
самое минимальное использование памяти по сравнению с предудушими скрипатми.
При поиске рандомного числа не используется список, а число при каждом проходе генерируется заного,
и если оно четное то в ответ записывается переменная i путем склеивания строки
Памяти ест мало, но дальнейшее использование пермернных практически невозможно, только в редких случаях
На этот скрипт выбоу упадет если нужно будет обработь большой массик цифр и сделать вычисления , 
но ни как не хранения разных типов данных.  
"""