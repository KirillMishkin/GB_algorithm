# -*- coding: utf-8 -*-
"""
Created on Tue Apr 21 17:41:04 2020

@author: mkv10
"""


"""
less_3_task_2
2. Во втором массиве сохранить индексы четных элементов первого массива.
 Например, если дан массив со значениями 8, 3, 15, 6, 4, 2,
второй массив надо заполнить значениями 0, 3, 4, 5 (помните, что индексация начинается с нуля),
т. к. именно в этих позициях первого массива стоят четные числа.
"""

import sys
from pympler import asizeof
from random import randint


def memory_func(mem):
    if type(mem) is dict or type(mem) is list:
        return f'asizeof - {asizeof.asizeof(mem)}, sys - {sys.getsizeof(mem)}'
    #sys показывает сам размер списка без его содержимого
    # asizeof показввает всю пасять вместе с содержимым списка
    return sys.getsizeof(mem)


def even_func(m: int):
    lst = [randint(0, m * 2) for _ in range(m + 1)]
    # Храниим переменные в Листе
    d = {}
    # Индексы и значения будем харнить в слвоаре
    for i, v in enumerate(lst):
        if v % 2 == 0:
            if d.get(i) is None:
                d[i] = None
            d[i] = v
    return print(f'Размер исходного кортежа {memory_func(lst)}\n'
                 f'Размер созданного словаря {memory_func(d)}\n'
                 f'Размер переменнной num {memory_func(m)}')


num = 1000
even_func(num)


"""
самый жирный скрипт, где используется словарь.
Потребляет в 2 раза больше чем список , очень хорошь для структурирования 
 данных и быстроего поиска по большим объемам, но не для оптимального использваония данных 
 Для хранения статических данных, когда список генерируется 1 раз, хорошо подойдет кортеж, 
 так как список потребляет большее количесов памяти.
"""