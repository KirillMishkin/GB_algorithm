
Анализ проводил по задание Урок 3 задание 4.

В этом задание нужно было найти число которое чаще всего встречается в массиве. 


за N вычисления я брал диапозона range(1,n) а так же random.randint(1,n//2) .
n//2 использовал , что бы исключить шанс выпадения чисел по 1 разу в массиве. 

Я был уверерн что нашел оптивальный вариант для решеия этого задания, но после того как написал еще два разных решения, 
то был весьма удивлен. 

test_time_1 - то что я оправлял как выполнение ДЗ

test_time_2  - Новый код, в нем использовался словарь для поиска 

test_time_3 - использовал методом count() для поика количесства повторений числа в списке

После того, как я написал test_time_3, на 100 % был уверен, что это будет самый быстрый поиск , но я ошибался. 
Быстрее всего работаает  test_time_2. 

На минимальных значения диапозона поиска n = 10, n = 20 , 50 , все алгоримы работают быстро, но когда диапозон чисел уходит за 100,
то уже начинаются проблемы со временем поиска. 

test_time_1 остановился на n = 500 , так как дальше не было смысла вычислять, 
время поиска при 1000-ном выполнение алгоритма было очень большое, и на n=1000 я не решился.

----------------------------------------------

test_time_3 проверки проходил до n = 5000, на этом диапозоне уже начались проблемы со временем. 
В этом коде использовались:
1) Поиск наибольшего числа 
2) методы cont() для массива, что бы сумму количесвао элементов в массиве
3) так же был сделан отдельный массив array_set = ser(array), чтобы исключить повторый поиск элементов для сокращения времени.

Но и это на больших значениях не помогло. 
при увеличение значения в 2 раза время выполнения увеличивалось в 4

----------------------------------------------------

test_time_2 првоерку проходил до n = 5000 , можно было и дальше проверять,но не имело смылсла. 
Использовался словарь, для хранения элементов. если ключ уже был в словаре , то там просходило сложение d[i]+=1 
и поиск проиходил по всем занчениям массива. 
На сравнение уже было видно, что для поиска в диапозоне n = 5000  потребовалось в 24 раза меньше времени , чем в test_time_3

Так что мой выбор выпал на test_time_2 , где использовался словарь для хранения данных и их поиска
